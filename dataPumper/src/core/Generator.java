package core;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.PreparedStatement;
import java.util.List;
import java.util.Map;
import java.util.Set;

import connection.DBMSConnection;
import basicDatatypes.*;

public class Generator {
	private Connection conn;
	private long progression = 0;
	
	public Generator(Connection conn){
		this.conn = conn;
	}
	
	public String nextString(){
		return "rnd" + (++progression);
	}
	
	/**
	 * @author tir
	 * @param tableName
	 * @param domainIndependentCols : May be null, and it specifies what columns HAVE TO be considered as domainIndependent.
	 * 
	 * Pump the table, column by column. Each element will be randomly chosen 
	 * according to the distribution of the database. Primary keys, instead, will
	 * be newly generated
	 * 
	 * Domain independent columns will be generated by taking values from the domain 
	 * (that is retrieved by a projection on the database column
	 *  -- therefore I assume that the db is NON-EMPTY [as in FactPages])
	 * 
	 * Domain independend columns can also be inferred, by looking at the projection and comparing it 
	 * against the total number of tuples in the table <b>tableName</b>
	 */
	public void pumpTable(String tableName, int nRows, List<String> domainIndependentCols, boolean inferDomainIndependent){		
		
			Generator gen = new Generator(conn);
			Schema schema = gen.getTableSchema(tableName);
			
			String templateInsert = createInsertTemplate(schema);
			
			// By understanding the types, one can decide what to generate
		
			for( String colName : schema.getColNames() ){
				switch(schema.getType(colName)){
				case java.sql.Types.INTEGER: {
					if(!domainIndependentCols.contains(colName)){
						// Do we want to insert boundaries?
						
					}
				}
				}
			}
			
//			for( int i = 0; i < rsmd.getColumnCount(); i++ ){
//			switch(rsmd.getColumnType(i)){
//			case java.sql.Types.INTEGER: {
//			
//			};
//			}
			
	}
	
//	ResultSet pks = conn.getMetaData().getPrimaryKeys(null, null, tableName);
//	
//			while (pks.next()) {
//	String columnName = pks.getString("COLUMN_NAME");
//	System.out.println("getPrimaryKeys(): columnName=" + columnName);
//	}
//	}
	
	
	/**
	 * 
	 * @author tir
	 * @param s: Schema of the table for which an insert query has to be created
	 * @return A template insert query with a suitable number of placeholders
	 */
	public String createInsertTemplate(Schema s){
		StringBuilder insertQuery = new StringBuilder();
		insertQuery.append("INSERT into "+s.getTableName()+" (");
		int i = 0;
		
		for( String colName : s.getColNames() ){
			insertQuery.append(colName);
			if( ++i < s.getNumColumns() )
				insertQuery.append(", ");
		}
		insertQuery.append(") VALUES (");
		
		for( i = 0; i < s.getNumColumns(); ++i ){
			insertQuery.append("?");
			if( i < s.getNumColumns() )
				insertQuery.append(", ");
		}
		insertQuery.append(");");
		
		return insertQuery.toString();
	}
	
	
	public Schema getTableSchema(String tableName){
		Schema schema = new Schema();
		try {
			PreparedStatement stmt;
			stmt = conn.prepareStatement("select * from "+tableName+" where 1<>1;");
			
			ResultSet result = stmt.executeQuery();
			ResultSetMetaData rsmd = result.getMetaData();
						
			for( int i = 1; i <= rsmd.getColumnCount(); ++i ){
				schema.addMap(rsmd.getColumnName(i), rsmd.getColumnType(i));
			}
		}
		catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		schema.setTableName(tableName);
		return schema;
		
	}
};

class Domain<T>{
	protected T min;
	protected T max;
}