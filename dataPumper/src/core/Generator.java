package core;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.PreparedStatement;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import basicDatatypes.*;

public class Generator {
	private Connection conn;
	private RandomDBValuesGenerator random;
	
	public Generator(Connection conn){
		this.conn = conn;
		random = new RandomDBValuesGenerator();
	}
	
	/**
	 * @author tir
	 * @param tableName
	 * @param domainIndependentCols : May be null, and it specifies what columns HAVE TO be considered as domainIndependent.
	 * @param duplicateRatio : Probability of generating a duplicate value while populating the columns
	 * 
	 * Pump the table, column by column. Each element will be randomly chosen 
	 * according to the distribution of the database. Primary keys, instead, will
	 * be newly generated
	 * 
	 * Domain independent columns will be generated by taking values from the domain 
	 * (that is retrieved by a projection on the database column
	 *  -- therefore I assume that the db is NON-EMPTY [as in FactPages])
	 * 
	 * Domain independend columns can also be inferred, by looking at the projection and comparing it 
	 * against the total number of tuples in the table <b>tableName</b>
	 */
	public void pumpTable(String tableName, int nRows, Schema schema, boolean inferDomainIndependent, float duplicateRatio){		
		
		String templateInsert = createInsertTemplate(schema);
		PreparedStatement stmt = null;
		
		try {
			stmt = conn.prepareStatement(templateInsert);
			System.out.println(templateInsert);
			// Disable auto-commit
			conn.setAutoCommit(false);
			
			for( int j = 0; j < nRows; ++j ){
				
				// By understanding the types, one can decide what to generate
				int i = 0;
				for( String colName : schema.getColNames() ){
					switch(schema.getType(colName)){
					case INT: {
						stmt.setInt(++i, random.getRandomInt(schema, colName));
						break;
					}
					case CHAR:
						break;
					case DATETIME:
						break;
					case LINESTRING:
						break;
					case LONGTEXT:
						break;
					case MULTILINESTRING:
						break;
					case MULTIPOLYGON:
						break;
					case POINT:
						break;
					case POLYGON:
						break;
					case TEXT:
						break;
					case VARCHAR : {
						stmt.setString(++i, random.getRandomString(schema, colName));
						break;
					}

					default:
						break;
					}
				}
				stmt.addBatch();
				
//				if(j % 1000 == 1){ stmt.executeBatch(); conn.commit(); }
				
			} // End of REPEAT nRows
			stmt.executeBatch();	
			conn.commit();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	/**
	 * 
	 * @param s
	 * @return
	 * 
	 * Types in FactPages db
	 * int, datetime, varchar, decimal, char, text, longtext, point, linestring, polygon, multipolygon, multilinestring
	 */
	public void fillDomainBoundaries(Schema s){
		
		Map<String, Domain<?>> domains = new HashMap<String, Domain<?>>();

		try {
			Template t = new Template("select ? from "+s.getTableName()+";");
			PreparedStatement stmt;
						
			for( String colName : s.getColNames() ){
				
				switch(s.getType(colName)){
				case INT : {
					
					// TODO One has to understand whether the domain is dependent to the db size or not.
					
					t.setNthPlaceholder(1, "min("+colName+"), max("+colName+")");
					
					stmt = conn.prepareStatement(t.getFilled());
					ResultSet result = stmt.executeQuery();
										
					while( result.next() ){
						domains.put(colName, new Domain<Integer>(result.getInt(1), result.getInt(2)));
					}
					break;
				}
				case CHAR : {
					break;
				}
				case VARCHAR : {
					break;
				}
				case TEXT : {
					break;
				}
				case LONGTEXT : {
					break;
				}
				case DATETIME : {
					// Not sure whether etc.
					break;
				}
				case POINT : {
					break;
				}
				case LINESTRING : {
					break;
				}
				case MULTILINESTRING : {
					break;
				}
				case POLYGON : {
					break;
				}
				case MULTIPOLYGON : {
					break;
				}
				}
			}
		}catch(SQLException e){
			e.printStackTrace();
		}
		s.setDomains(domains);
	}
	/**
	 * 
	 * @author tir
	 * @param s: Schema of the table for which an insert query has to be created
	 * @return A template insert query with a suitable number of place-holders
	 */
	public String createInsertTemplate(Schema s){
		StringBuilder insertQuery = new StringBuilder();
		insertQuery.append("INSERT into "+s.getTableName()+" (");
		int i = 0;
		
		for( String colName : s.getColNames() ){
			insertQuery.append(colName);
			if( ++i < s.getNumColumns() )
				insertQuery.append(", ");
		}
		insertQuery.append(") VALUES (");
		
		for( i = 0; i < s.getNumColumns(); ++i ){
			insertQuery.append("?");
			if( i < s.getNumColumns() - 1 )
				insertQuery.append(", ");
		}
		insertQuery.append(")");
		
		return insertQuery.toString();
	}
	
	public Schema getTableSchema(String tableName){
		Schema schema = new Schema(tableName);
		
		try{
			PreparedStatement stmt;
			stmt = conn.prepareStatement("DESCRIBE "+tableName);
			ResultSet result = stmt.executeQuery();
			
			// Field - Type - Null - Default - Extra
			while(result.next()){
				schema.addField(result.getString(1), result.getString(2));
				
				// Primary keys need to be all different
				if( result.getString(3).equals("PRI") ) 
					schema.setAllDifferent(result.getString(1), true);
				else schema.setAllDifferent(result.getString(1), false);
			}
			
			// Now let's retrieve foreign keys
			String informationSchemaQuery = 
					"select TABLE_NAME,COLUMN_NAME,CONSTRAINT_NAME, REFERENCED_TABLE_NAME,REFERENCED_COLUMN_NAME"
					+ " from INFORMATION_SCHEMA.KEY_COLUMN_USAGE"
					+ "	where TABLE_NAME = ? and constraint_schema = ?"
					+ " and REFERENCED_TABLE_NAME != 'null'";
					
			stmt = conn.prepareStatement(informationSchemaQuery);
			stmt.setString(1, tableName);
			stmt.setString(2, conn.getCatalog());
			
			result = stmt.executeQuery();
			
			while(result.next()){
				schema.setForeignKey(result.getString(2), result.getString(5), result.getString(4));
			}
		}
		catch(SQLException e){
			e.printStackTrace();
		}
		return schema;
	}
	/**
	 * It retrieves all the table names from the database
	 * 
	 * @param dbName
	 * @return 
	 */
	public List<String> getAllTableNamesOf(String dbName){
		
		List<String> tableNames = new LinkedList<String>();
		
		// Get all the schemas
		try {
			DatabaseMetaData dbmd = conn.getMetaData();
			
			ResultSet rs = dbmd.getTables(dbName, null, null, null);
			
			while( rs.next() ){
				tableNames.add(rs.getString(3));
			}			
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return tableNames;
	}
};