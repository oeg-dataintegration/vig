package core;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.PreparedStatement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Queue;

import connection.DBMSConnection;
import core.test.GeneratorTest;
import basicDatatypes.*;

import org.apache.log4j.Logger;

public class Generator {
	private DBMSConnection dbmsConn;
	private RandomDBValuesGenerator random;
	private Statistics statistics;
	
	private static Logger logger = Logger.getLogger(GeneratorTest.class.getCanonicalName());
	
	// Internal state
	private Map<String, Queue<ResultSet>> chasedValues; // Pointers to ResultSets storing chased values for each column
	private Map<String, ResultSet> duplicateValues;     // Pointers to ResultSets storing duplicate values for each column
		
	public Generator(DBMSConnection dbmsConn){
		this.dbmsConn = dbmsConn;
		random = new RandomDBValuesGenerator();
		this.statistics = new Statistics(dbmsConn);
		
		chasedValues = new HashMap<String, Queue<ResultSet>>();
		duplicateValues = new HashMap<String, ResultSet>();
	}
	
	/**
	 * @author tir
	 * @param tableName
	 * @param domainIndependentCols : May be null, and it specifies what columns HAVE TO be considered as domainIndependent.
	 * @param duplicateRatio : Probability of generating a duplicate value while populating the columns
	 * 
	 * Pump the table, column by column. Each element will be randomly chosen 
	 * according to the distribution of the database. Primary keys, instead, will
	 * be newly generated
	 * 
	 * Domain independent columns will be generated by taking values from the domain 
	 * (that is retrieved by a projection on the database column
	 *  -- therefore I assume that the db is NON-EMPTY [as in FactPages])
	 * 
	 * Domain independend columns can also be inferred, by looking at the projection and comparing it 
	 * against the total number of tuples in the table <b>tableName</b>
	 */
	public void pumpTable(int nRows, Schema schema){		
		
		// INIT

		chasedValues.clear();  
		duplicateValues.clear();
		
		Map<String, Integer> mNumChases = new HashMap<String, Integer>(); // It holds the number of chased elements for each column
		Map<String, Integer> mNumDuplicates = new HashMap<String, Integer>(); // It holds the number of duplicates that have to be inserted
		Map<String, Integer> mNumDuplicatesFromFresh = new HashMap<String, Integer>(); // It holds the number of duplicates
		                                                                               // ---among fresh values--- that need to be inserted
		
		Queue<String> freshDuplicates = new LinkedList<String>(); // TODO Is this too much memory consuming?
		int freshGenerated = 0; // Keeps the number of randomly generated values
		
		for( Column column : schema.getColumns() ){
			chasedValues.put(column.getName(), fillChase(column, schema.getTableName(), mNumChases));
			duplicateValues.put(column.getName(), fillDuplicates(column, schema.getTableName(), nRows, mNumDuplicates, mNumDuplicatesFromFresh));
		}
		
		// ----- END INIT ----- //
		
		String templateInsert = dbmsConn.createInsertTemplate(schema);
		PreparedStatement stmt = null;
		
		try {
			stmt = dbmsConn.getPreparedStatement(templateInsert);
			logger.debug(templateInsert);
			
			// Disable auto-commit
			dbmsConn.setAutoCommit(false);

			// TODO
			// What are the domains in which to take random values?
			// Let's do it later
			
			// TODO The max_cycle thing
			
			for( int j = 0; j < nRows; ++j ){
				
				int columnIndex = 0;
				for( Column column : schema.getColumns() ){
					
					if( canAdd(nRows, j, mNumChases.get(column.getName())) )  {
						
						dbmsConn.setter(stmt, ++columnIndex, column.getType(), pickNextChased(schema, column)); // Ensures to put all chased elements, in a uniform way w.r.t. other columns
					
					}
					else if( canAdd(nRows, j, mNumDuplicates.get(column.getName()) ) ){
						
						String nextDuplicate = pickNextDupFromOldValues(schema, column);
						if( nextDuplicate == null ){ // Necessary to start picking duplicates from freshly generated values
							nextDuplicate = freshDuplicates.poll();
						}
						dbmsConn.setter(stmt, ++columnIndex, column.getType(), nextDuplicate); // Ensures to put all chased elements, in a uniform way w.r.t. other columns
					
					}
					else{ // Add a random value; if I want to duplicate afterwards, keep it in freshDuplicates list
						
						String generatedRandom = random.getRandomValue(column);
						dbmsConn.setter(stmt, ++columnIndex, column.getType(), generatedRandom);
						// Add the random value to the "toInsert" duplicates
						if( ++freshGenerated < mNumDuplicatesFromFresh.get(column.getName()) ){
							freshDuplicates.add(generatedRandom); 
						}
					}
				}
				stmt.addBatch();
			} 
			stmt.executeBatch();	
			dbmsConn.commit();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	/**
	 * 
	 * @param column
	 * @param tableName
	 * @param nRowsToInsert
	 * @return A result set containing the number of duplicates---taken from the original set--- that need to be inserted
	 */
	private ResultSet fillDuplicates(Column column, String tableName, int nRowsToInsert, 
			Map<String, Integer> mNumDuplicates, Map<String, Integer> mNumDuplicatesFromFresh) {
		
		ResultSet result = null;
		
		// First of all, I need to understand the distribution of duplicates. Window analysis!
		float ratio = statistics.naiveStrategy(column.getName(), tableName);
		
		int curRows = statistics.nRows(column.getName(), tableName);
		
		int nDups = Math.round((nRowsToInsert + curRows) * ratio); // This is the total number of duplicates that need to be inserted
		
		mNumDuplicates.put(tableName, nDups);
		
		// Now, establish how many rows I want to take from the current content
		int nDupsFromCurCol = Math.round(curRows * ratio);
		
		// And how many rows I want to take from fresh randomly generated values.
		mNumDuplicatesFromFresh.put(tableName, nDups - nDupsFromCurCol);
		
		// Point to the rows that I want to duplicate
		int indexMin = random.getRandomInt(curRows - nDupsFromCurCol);
		int indexMax = indexMin + nDupsFromCurCol;
		
		String queryString = "SELECT "+column.getName()+ " FROM "+tableName+" LIMIT "+indexMin+", "+indexMax;
		
		try{
			PreparedStatement stmt = dbmsConn.getPreparedStatement(queryString);
			result = stmt.executeQuery();
		} catch (SQLException e) {
			e.printStackTrace();
		}
		
		return result;
	}
	
	/**
	 * Side effect on <b>numChased</b>
	 * @param column
	 * @param tableName
	 * @param numChased
	 * @return
	 */
	private Queue<ResultSet> fillChase(Column column, String tableName, Map<String, Integer> mNumChases) {
		Queue<ResultSet> result = new LinkedList<ResultSet>(); 
		
		// SELECT referredByCol FROM referredByTable WHERE referredByCol NOT IN (SELECT column.name() FROM schema.name()); 
		Template query = new Template("SELECT DISTINCT ? FROM ? WHERE ? NOT IN (SELECT ? FROM ?)");
		Template queryCount = new Template("SELECT COUNT(DISTINCT ?) FROM ? WHERE ? NOT IN (SELECT ? FROM ?)");
		
		for( QualifiedName referencedBy : column.referencedBy() ){
			// Fill the query
			query.setNthPlaceholder(1,referencedBy.getColName());
			query.setNthPlaceholder(2, referencedBy.getTableName());
			query.setNthPlaceholder(3, referencedBy.getColName());
			query.setNthPlaceholder(4, column.getName());
			query.setNthPlaceholder(5, tableName);
			
			queryCount.setNthPlaceholder(1,referencedBy.getColName());
			queryCount.setNthPlaceholder(2, referencedBy.getTableName());
			queryCount.setNthPlaceholder(3, referencedBy.getColName());
			queryCount.setNthPlaceholder(4, column.getName());
			queryCount.setNthPlaceholder(5, tableName);
			
			try {
				PreparedStatement stmt = dbmsConn.getPreparedStatement(query);
				ResultSet rs = stmt.executeQuery();
				result.add(rs);
				
				PreparedStatement stmt1 = dbmsConn.getPreparedStatement(queryCount);
				ResultSet rs1 = stmt1.executeQuery();
				if(mNumChases.containsKey(column.getName())){
					mNumChases.put(column.getName(), mNumChases.get(column.getName()) + rs.getInt(1)); // Add to the current value
				}
				else{
					mNumChases.put(column.getName(), rs1.getInt(1)); // Create a new entry for the column
				}
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
		return result;
	}

	private String pickNextDupFromOldValues(Schema schema, Column column) {
		
		ResultSet duplicatesToInsert = duplicateValues.get(column.getName());
		String result = null;
		
		try {
			if( !duplicatesToInsert.next() ) return null;
			result = duplicatesToInsert.getString(1);
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return result;
	}

	private String pickNextChased(Schema schema, Column column) {
		
		Queue<ResultSet> chased = chasedValues.get(column.getName());
		ResultSet curSet = chased.peek();

		if(curSet == null){ // This shall not happen
			logger.debug("Problem: Picked a null in chased vector"); 
			return null;
		}
		try {
			if(curSet.next()){
				return curSet.getString(1);
			}
			else{ // Pick next ResultSet
				chased.poll();
				curSet = chased.peek();
				if(curSet == null ) return null;
				
				if( curSet.next() == false ) 
					logger.debug("Problem: No element in a non-empty ResultSet");
				curSet.getString(1);
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}		
		return null;
	}

	private boolean canAdd(int total, int current, int modulo) {
		if(modulo == 0) return false;
		if( total % modulo == 0 )
			return current % (total / modulo) == 0;
		return current % (total / (modulo + 1)) == 0;
	}
};